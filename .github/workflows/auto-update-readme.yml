name: Auto Update README

on:
  push:
    branches: [main]
    paths:
      - 'skills/**/rules/*.md'
      - 'skills/**/SKILL.md'

jobs:
  update-readme:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.14'

      - name: Generate and update README
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          import re
          from pathlib import Path
          from typing import Dict, List, Tuple

          def parse_yaml_frontmatter(file_path: Path) -> Dict[str, str]:
              """Parse YAML frontmatter from a markdown file."""
              with open(file_path, 'r', encoding='utf-8') as f:
                  content = f.read()
              
              # Extract frontmatter between --- markers
              match = re.match(r'^---\s*\n(.*?)\n---\s*\n', content, re.DOTALL)
              if not match:
                  return {}
              
              frontmatter = {}
              for line in match.group(1).split('\n'):
                  if ':' in line:
                      key, value = line.split(':', 1)
                      frontmatter[key.strip()] = value.strip()
              
              return frontmatter

          def get_skill_info(skill_dir: Path) -> Tuple[str, str, List[Dict]]:
              """Get skill name, description and rules from a skill directory."""
              skill_md = skill_dir / 'SKILL.md'
              if not skill_md.exists():
                  return '', '', []
              
              with open(skill_md, 'r', encoding='utf-8') as f:
                  skill_content = f.read()
              
              # Parse skill frontmatter
              skill_meta = parse_yaml_frontmatter(skill_md)
              skill_name = skill_meta.get('name', skill_dir.name)
              skill_desc = skill_meta.get('description', '')
              
              # Get all rule files
              rules_dir = skill_dir / 'rules'
              if not rules_dir.exists():
                  return skill_name, skill_desc, []
              
              rules = []
              for rule_file in sorted(rules_dir.glob('*.md')):
                  rule_meta = parse_yaml_frontmatter(rule_file)
                  if rule_meta:
                      rules.append({
                          'file': rule_file.name,
                          'title': rule_meta.get('title', rule_file.stem),
                          'type': rule_meta.get('type', 'capability'),
                          'impact': rule_meta.get('impact', 'MEDIUM'),
                          'tags': rule_meta.get('tags', ''),
                          'path': str(rule_file.relative_to(Path.cwd()))
                      })
              
              return skill_name, skill_desc, rules

          def format_skill_section(skill_name: str, rules: List[Dict]) -> str:
              """Format a skill section with its rules."""
              if not rules:
                  return ''
              
              # Count rules by type
              capability_rules = [r for r in rules if r['type'] == 'capability']
              efficiency_rules = [r for r in rules if r['type'] == 'efficiency']
              
              # Map skill names to display names
              skill_display_names = {
                  'nextdns-api': 'NextDNS API',
                  'nextdns-cli': 'NextDNS CLI',
                  'nextdns-ui': 'NextDNS UI',
                  'integrations': 'Integrations'
              }
              
              display_name = skill_display_names.get(skill_name, skill_name)
              total_count = len(rules)
              
              output = f"### {skill_name} ({total_count} rules)\n\n"
              
              # Get description based on skill
              descriptions = {
                  'nextdns-api': 'NextDNS API integration best practices covering authentication, profile management, analytics, logs, and real-time streaming.',
                  'nextdns-cli': 'NextDNS CLI client best practices for installation, configuration, and management of DNS-over-HTTPS proxy.',
                  'nextdns-ui': 'NextDNS Web UI configuration and management best practices via the web dashboard.',
                  'integrations': 'NextDNS integration guides for third-party platforms and services including routers, network management, and home automation.'
              }
              
              output += descriptions.get(skill_name, '') + "\n\n"
              
              # Create table
              output += "| Type       | Count | Examples                                                                                                                                                   |\n"
              output += "|:-----------|:------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------|\n"
              
              # Capability row
              if capability_rules:
                  cap_examples = ', '.join([r['title'] for r in capability_rules[:8]])
                  if len(capability_rules) > 8:
                      cap_examples += '...'
                  output += f"| Capability | {len(capability_rules):<5} | {cap_examples:<154} |\n"
              else:
                  output += f"| Capability | 0     | None                                                                                                                                                       |\n"
              
              # Efficiency row
              if efficiency_rules:
                  eff_examples = ', '.join([r['title'] for r in efficiency_rules[:8]])
                  if len(efficiency_rules) > 8:
                      eff_examples += '...'
                  output += f"| Efficiency | {len(efficiency_rules):<5} | {eff_examples:<154} |\n"
              else:
                  output += f"| Efficiency | 0     | Future additions                                                                                                                                           |\n"
              
              output += "\n"
              return output

          def main():
              """Main function to update README.md."""
              repo_root = Path.cwd()
              skills_dir = repo_root / 'skills'
              readme_path = repo_root / 'README.md'
              
              if not skills_dir.exists() or not readme_path.exists():
                  print("Error: skills directory or README.md not found")
                  return
              
              # Get all skill directories
              skill_order = ['nextdns-api', 'nextdns-cli', 'nextdns-ui', 'integrations']
              skills_data = {}
              
              for skill_dir in sorted(skills_dir.iterdir()):
                  if skill_dir.is_dir():
                      skill_name, skill_desc, rules = get_skill_info(skill_dir)
                      if rules:
                          skills_data[skill_name] = rules
              
              # Generate the skills section
              skills_content = ""
              for skill_name in skill_order:
                  if skill_name in skills_data:
                      skills_content += format_skill_section(skill_name, skills_data[skill_name])
              
              # Read README.md
              with open(readme_path, 'r', encoding='utf-8') as f:
                  readme = f.read()
              
              # Find and replace content between markers
              start_marker = "## Available Skills"
              end_marker = "## Rule Types"
              
              pattern = re.compile(
                  f"({re.escape(start_marker)})(.*?)({re.escape(end_marker)})",
                  re.DOTALL
              )
              
              if not pattern.search(readme):
                  print("Error: Could not find markers in README.md")
                  print(f"Looking for: '{start_marker}' and '{end_marker}'")
                  return
              
              new_readme = pattern.sub(
                  f"\\1\n\n{skills_content}\\3",
                  readme
              )
              
              # Write back to README.md
              with open(readme_path, 'w', encoding='utf-8') as f:
                  f.write(new_readme)
              
              print("âœ… README.md updated successfully!")
              print(f"Total skills processed: {len(skills_data)}")
              for skill_name, rules in skills_data.items():
                  print(f"  - {skill_name}: {len(rules)} rules")

          if __name__ == '__main__':
              main()
          PYTHON_SCRIPT

      - name: Commit and push changes
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          commit_message: 'docs: auto-update README.md with latest rules'
          file_pattern: 'README.md'
          commit_user_name: 'github-actions[bot]'
          commit_user_email: 'github-actions[bot]@users.noreply.github.com'
          commit_author: 'github-actions[bot] <github-actions[bot]@users.noreply.github.com>'
